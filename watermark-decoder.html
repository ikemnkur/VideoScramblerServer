<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forensic Video Watermark Decoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #0f0f23;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="file"],
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:hover {
            border-color: #0f0f23;
        }

        input:focus {
            outline: none;
            border-color: #0f0f23;
        }

        .options-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .options-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        button {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(15, 15, 35, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            border-left: 4px solid #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .result-box {
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            text-align: center;
            display: none;
        }

        .result-box h2 {
            color: white;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .tracking-id {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin: 15px 0;
        }

        .details {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            text-align: left;
        }

        .details h3 {
            color: #1a1a2e;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .details table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .details th,
        .details td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .details th {
            background: #f5f5f5;
            font-weight: 600;
            color: #555;
        }

        .layer-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-right: 5px;
        }

        .layer-1 {
            background: #e91e63;
            color: white;
        }

        .layer-2 {
            background: #2196f3;
            color: white;
        }

        .confidence-high {
            color: #388e3c;
            font-weight: bold;
        }

        .confidence-medium {
            color: #f57c00;
            font-weight: bold;
        }

        .confidence-low {
            color: #c62828;
            font-weight: bold;
        }

        .preview {
            margin-top: 20px;
        }

        video {
            width: 100%;
            max-height: 400px;
            border-radius: 8px;
            background: #000;
        }

        .info-box {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #555;
        }

        .info-box h3 {
            color: #0f0f23;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .info-box ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .info-box li {
            margin-bottom: 4px;
        }

        .binary-display {
            font-family: monospace;
            background: #333;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        /* Manual Entry Button */
        .manual-entry-btn {
            background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%);
            margin-top: 15px;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .modal h2 {
            color: #9c27b0;
            margin-bottom: 10px;
            font-size: 22px;
        }

        .modal-subtitle {
            color: #666;
            font-size: 13px;
            margin-bottom: 20px;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            width: auto;
            padding: 5px 10px;
        }

        .modal-close:hover {
            color: #333;
            transform: none;
            box-shadow: none;
        }

        /* 5x5 Grid */
        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            max-width: 280px;
            margin: 20px auto;
        }

        .grid-cell {
            aspect-ratio: 1;
            border: 2px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #999;
        }

        .grid-cell:hover {
            border-color: #9c27b0;
        }

        .grid-cell.active {
            background: #1a1a2e;
            border-color: #1a1a2e;
        }

        .grid-cell.finder {
            cursor: not-allowed;
            opacity: 0.7;
        }

        .grid-cell.finder.active {
            background: #9c27b0;
            border-color: #9c27b0;
        }

        .grid-cell.finder.inactive {
            background: #fff;
            border-color: #9c27b0;
        }

        .grid-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid;
        }

        .legend-box.finder {
            background: #9c27b0;
            border-color: #9c27b0;
        }

        .legend-box.data {
            background: #1a1a2e;
            border-color: #1a1a2e;
        }

        .manual-result {
            margin-top: 20px;
            padding: 20px;
            background: linear-gradient(135deg, #9c27b0 0%, #673ab7 100%);
            border-radius: 8px;
            text-align: center;
            color: white;
        }

        .manual-result-id {
            font-size: 36px;
            font-weight: bold;
            margin: 10px 0;
        }

        .manual-result-binary {
            font-family: monospace;
            font-size: 14px;
            opacity: 0.9;
        }

        .grid-instructions {
            background: #f5f5f5;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            color: #555;
            margin-bottom: 15px;
        }

        .grid-instructions strong {
            color: #9c27b0;
        }

        .reset-grid-btn {
            background: #f44336;
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 14px;
        }

        .bit-order-diagram {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            max-width: 200px;
            margin: 10px auto;
            font-size: 10px;
        }

        .bit-order-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f0f0;
            border-radius: 2px;
            color: #666;
        }

        .bit-order-cell.finder-cell {
            background: #e1bee7;
            color: #9c27b0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Forensic Video Watermark Decoder</h1>
        <p class="subtitle">Extract tracking ID from watermarked video using dual-layer detection</p>

        <div class="input-group">
            <label for="videoFile">Select Watermarked Video:</label>
            <input type="file" id="videoFile" accept="video/*">
        </div>

        <div class="options-row">
            <div class="input-group">
                <label for="origWidth">Original Width (for edge crop detection):</label>
                <input type="number" id="origWidth" placeholder="e.g., 1920">
            </div>
            <div class="input-group">
                <label for="origHeight">Original Height (for edge crop detection):</label>
                <input type="number" id="origHeight" placeholder="e.g., 1080">
            </div>
        </div>

        <button id="decodeBtn">Decode Watermark</button>

        <div id="status"></div>

        <div class="preview" id="previewSection" style="display: none;">
            <h3>Video Preview:</h3>
            <video id="videoPreview" controls></video>
        </div>

        <div class="result-box" id="resultBox">
            <h2>Tracking ID Detected</h2>
            <div class="tracking-id" id="trackingIdDisplay">-</div>
            <div class="binary-display" id="binaryDisplay"></div>
            <div class="details">
                <h3>Detection Details:</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Detection Method</th>
                            <th>Result</th>
                            <th>Confidence</th>
                        </tr>
                    </thead>
                    <tbody id="detailsBody">
                    </tbody>
                </table>
            </div>
        </div>

        <button id="manualEntryBtn" class="manual-entry-btn">Manual Pattern Entry</button>

        <div class="info-box">
            <h3>Decoding Process:</h3>
            <ul>
                <li><span class="layer-badge layer-1">Layer 1</span><strong>Marker Detection:</strong> Scans multiple frames for finder patterns, extracts binary data from detected markers</li>
                <li><span class="layer-badge layer-2">Layer 2</span><strong>Edge Crop Analysis:</strong> Compares current dimensions to original to calculate removed pixels</li>
                <li><strong>Cross-validation:</strong> Compares results from both layers for higher confidence</li>
                <li><strong>Note:</strong> For edge crop detection, you need to know the original video dimensions</li>
            </ul>
        </div>
    </div>

    <!-- Manual Pattern Entry Modal -->
    <div class="modal-overlay" id="manualEntryModal">
        <div class="modal">
            <button class="modal-close" id="modalClose">&times;</button>
            <h2>Manual Pattern Entry</h2>
            <p class="modal-subtitle">Click the cells to match the pattern you see in the video</p>

            <div class="grid-instructions">
                <strong>Instructions:</strong> The center 3x3 cells (purple) are the finder pattern and cannot be changed.
                Click the outer 16 cells to toggle them on/off based on what you see in the leaked video.
                Dark squares = ON (filled), Light squares = OFF (empty).
            </div>

            <div class="pattern-grid" id="patternGrid">
                <!-- Grid cells will be generated by JavaScript -->
            </div>

            <div class="grid-legend">
                <div class="legend-item">
                    <div class="legend-box finder"></div>
                    <span>Finder Pattern (fixed)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-box data"></div>
                    <span>Data Bit (clickable)</span>
                </div>
            </div>

            <div class="grid-instructions" style="margin-top: 15px;">
                <strong>Bit Order:</strong>
                <div class="bit-order-diagram">
                    <div class="bit-order-cell">0</div>
                    <div class="bit-order-cell">1</div>
                    <div class="bit-order-cell">2</div>
                    <div class="bit-order-cell">3</div>
                    <div class="bit-order-cell">4</div>
                    <div class="bit-order-cell">5</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell">6</div>
                    <div class="bit-order-cell">7</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell">8</div>
                    <div class="bit-order-cell">9</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell finder-cell">F</div>
                    <div class="bit-order-cell">10</div>
                    <div class="bit-order-cell">11</div>
                    <div class="bit-order-cell">12</div>
                    <div class="bit-order-cell">13</div>
                    <div class="bit-order-cell">14</div>
                    <div class="bit-order-cell">15</div>
                </div>
            </div>

            <div class="manual-result" id="manualResult">
                <div>Decoded Tracking ID:</div>
                <div class="manual-result-id" id="manualTrackingId">0</div>
                <div class="manual-result-binary" id="manualBinary">Binary: 0000000000000000</div>
            </div>

            <button class="reset-grid-btn" id="resetGridBtn">Reset Grid</button>
        </div>
    </div>

    <script>
        const videoFileInput = document.getElementById('videoFile');
        const origWidthInput = document.getElementById('origWidth');
        const origHeightInput = document.getElementById('origHeight');
        const decodeBtn = document.getElementById('decodeBtn');
        const statusDiv = document.getElementById('status');
        const videoPreview = document.getElementById('videoPreview');
        const previewSection = document.getElementById('previewSection');
        const resultBox = document.getElementById('resultBox');
        const trackingIdDisplay = document.getElementById('trackingIdDisplay');
        const binaryDisplay = document.getElementById('binaryDisplay');
        const detailsBody = document.getElementById('detailsBody');

        let videoFile = null;

        videoFileInput.addEventListener('change', (e) => {
            videoFile = e.target.files[0];
            if (videoFile) {
                const url = URL.createObjectURL(videoFile);
                videoPreview.src = url;
                previewSection.style.display = 'block';
                resultBox.style.display = 'none';
                showStatus(`Video loaded: ${videoFile.name}`, 'info');
            }
        });

        decodeBtn.addEventListener('click', async () => {
            if (!videoFile) {
                showStatus('Please select a video file first!', 'error');
                return;
            }

            decodeBtn.disabled = true;
            resultBox.style.display = 'none';
            showStatus('Starting forensic watermark detection...', 'info');

            try {
                await decodeVideo(videoFile);
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                decodeBtn.disabled = false;
            }
        });

        // Convert binary array to number
        function fromBinaryArray(arr) {
            let num = 0;
            for (let i = 0; i < arr.length; i++) {
                num = (num << 1) | arr[i];
            }
            return num;
        }

        // Pseudo-random number generator with seed (must match encoder)
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Get expected marker position for a frame (must match encoder)
        function getMarkerPosition(frameNum, width, height, markerWidth, markerHeight) {
            const seed1 = frameNum * 12345 + 67890;
            const seed2 = frameNum * 98765 + 43210;

            const marginX = width * 0.2;
            const marginY = height * 0.2;
            const availableWidth = width - 2 * marginX - markerWidth;
            const availableHeight = height - 2 * marginY - markerHeight;

            const x = marginX + seededRandom(seed1) * availableWidth;
            const y = marginY + seededRandom(seed2) * availableHeight;

            return { x: Math.floor(x), y: Math.floor(y) };
        }

        // Detect finder pattern in image region
        function detectFinderPattern(imageData, x, y, cellSize) {
            const data = imageData.data;
            const width = imageData.width;

            // Expected finder pattern (3x3):
            // [1, 1, 1]
            // [1, 0, 1]
            // [1, 1, 1]
            const expected = [
                [1, 1, 1],
                [1, 0, 1],
                [1, 1, 1]
            ];

            let matches = 0;
            let total = 0;

            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    // Sample center of each cell
                    const sampleX = Math.floor(x + col * cellSize + cellSize / 2);
                    const sampleY = Math.floor(y + row * cellSize + cellSize / 2);

                    if (sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < imageData.height) {
                        const idx = (sampleY * width + sampleX) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;

                        // Dark = 1, Light = 0 (inverted from typical)
                        const isDark = brightness < 128;
                        const expectedDark = expected[row][col] === 1;

                        if (isDark === expectedDark) {
                            matches++;
                        }
                        total++;
                    }
                }
            }

            return matches / total;
        }

        // Read binary data from marker with multi-point sampling and adaptive threshold
        function readMarkerData(imageData, x, y, cellSize) {
            const data = imageData.data;
            const width = imageData.width;
            const bits = [];

            // First, calculate the brightness of finder pattern cells to establish threshold
            // Sample the known dark cells (corners) and known light cell (center)
            const finderSamples = { dark: [], light: [] };

            // Dark cells: (0,0), (0,2), (2,0), (2,2) and edges
            const darkPositions = [[0,0], [0,1], [0,2], [1,0], [1,2], [2,0], [2,1], [2,2]];
            const lightPositions = [[1,1]]; // Center is light

            for (const [row, col] of darkPositions) {
                const brightness = sampleCellBrightness(data, width, imageData.height, x, y, row, col, cellSize);
                if (brightness !== null) finderSamples.dark.push(brightness);
            }

            for (const [row, col] of lightPositions) {
                const brightness = sampleCellBrightness(data, width, imageData.height, x, y, row, col, cellSize);
                if (brightness !== null) finderSamples.light.push(brightness);
            }

            // Calculate adaptive threshold
            const avgDark = finderSamples.dark.length > 0
                ? finderSamples.dark.reduce((a, b) => a + b, 0) / finderSamples.dark.length
                : 64;
            const avgLight = finderSamples.light.length > 0
                ? finderSamples.light.reduce((a, b) => a + b, 0) / finderSamples.light.length
                : 192;

            // Threshold is midpoint between dark and light
            const threshold = (avgDark + avgLight) / 2;

            // Data bits are in a 4x3 grid starting at column 3
            for (let i = 0; i < 12; i++) {
                const row = Math.floor(i / 4);
                const col = 3 + (i % 4);

                const brightness = sampleCellBrightness(data, width, imageData.height, x, y, row, col, cellSize);

                if (brightness !== null) {
                    // White = 1, Black = 0, using adaptive threshold
                    bits.push(brightness >= threshold ? 1 : 0);
                } else {
                    bits.push(0);
                }
            }

            return bits;
        }

        // Sample brightness of a cell using multiple points for robustness
        function sampleCellBrightness(data, width, height, markerX, markerY, row, col, cellSize) {
            const samples = [];
            const offsets = [0.3, 0.5, 0.7]; // Sample at 30%, 50%, 70% of cell

            for (const ox of offsets) {
                for (const oy of offsets) {
                    const sampleX = Math.floor(markerX + col * cellSize + cellSize * ox);
                    const sampleY = Math.floor(markerY + row * cellSize + cellSize * oy);

                    if (sampleX >= 0 && sampleX < width && sampleY >= 0 && sampleY < height) {
                        const idx = (sampleY * width + sampleX) * 4;
                        const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                        samples.push(brightness);
                    }
                }
            }

            if (samples.length === 0) return null;

            // Return median for noise resistance
            samples.sort((a, b) => a - b);
            return samples[Math.floor(samples.length / 2)];
        }

        // Scan for finder pattern in a search region
        function scanForFinderPattern(imageData, searchX, searchY, searchWidth, searchHeight, cellSize) {
            const step = Math.floor(cellSize / 2);
            let bestMatch = { score: 0, x: 0, y: 0 };

            for (let y = searchY; y < searchY + searchHeight; y += step) {
                for (let x = searchX; x < searchX + searchWidth; x += step) {
                    const score = detectFinderPattern(imageData, x, y, cellSize);
                    if (score > bestMatch.score) {
                        bestMatch = { score, x, y };
                    }
                }
            }

            // Refine search around best match
            if (bestMatch.score > 0.6) {
                for (let dy = -step; dy <= step; dy += 2) {
                    for (let dx = -step; dx <= step; dx += 2) {
                        const x = bestMatch.x + dx;
                        const y = bestMatch.y + dy;
                        const score = detectFinderPattern(imageData, x, y, cellSize);
                        if (score > bestMatch.score) {
                            bestMatch = { score, x, y };
                        }
                    }
                }
            }

            return bestMatch;
        }

        // Find the red center dot in the frame
        function findRedCenterDot(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Search in the center region (middle 60% of frame)
            const searchMargin = 0.2;
            const startX = Math.floor(width * searchMargin);
            const endX = Math.floor(width * (1 - searchMargin));
            const startY = Math.floor(height * searchMargin);
            const endY = Math.floor(height * (1 - searchMargin));

            let bestMatch = { x: 0, y: 0, score: 0 };
            const step = 2; // Search every 2 pixels for speed

            for (let y = startY; y < endY; y += step) {
                for (let x = startX; x < endX; x += step) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];

                    // Look for red pixels (high R, low G, low B)
                    const redScore = r - Math.max(g, b);
                    if (redScore > 100 && r > 150) {
                        // Found a red pixel, calculate how "red" the surrounding area is
                        let areaScore = 0;
                        const radius = 3;
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                const nx = x + dx;
                                const ny = y + dy;
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nidx = (ny * width + nx) * 4;
                                    const nr = data[nidx];
                                    const ng = data[nidx + 1];
                                    const nb = data[nidx + 2];
                                    if (nr > 150 && nr - Math.max(ng, nb) > 80) {
                                        areaScore++;
                                    }
                                }
                            }
                        }
                        if (areaScore > bestMatch.score) {
                            bestMatch = { x, y, score: areaScore };
                        }
                    }
                }
            }

            if (bestMatch.score > 10) {
                return { x: bestMatch.x, y: bestMatch.y, found: true };
            }
            return { x: width / 2, y: height / 2, found: false };
        }

        // Decode tracking ID from edge cropping using red center dot
        function decodeFromEdgeCrop(currentWidth, currentHeight, origWidth, origHeight, centerDot) {
            if (!origWidth || !origHeight) {
                return null;
            }

            const baseUnit = 2;

            // If we found the red center dot, use it to calculate actual distances
            if (centerDot && centerDot.found) {
                // The center dot should be at the center of the cropped frame
                // Distance from dot to each edge tells us the crop amounts
                const dotX = centerDot.x;
                const dotY = centerDot.y;

                // Current distances from dot to edges
                const distLeft = dotX;
                const distRight = currentWidth - dotX;
                const distTop = dotY;
                const distBottom = currentHeight - dotY;

                // Original center position
                const origCenterX = origWidth / 2;
                const origCenterY = origHeight / 2;

                // Calculate how much was cropped from each side
                // Original distance to left edge was origCenterX
                // Current distance to left edge is dotX
                // So leftCrop = origCenterX - dotX (if positive)
                const leftCrop = Math.max(0, Math.round(origCenterX - dotX));
                const rightCrop = Math.max(0, Math.round(origCenterX - distRight));
                const topCrop = Math.max(0, Math.round(origCenterY - dotY));
                const bottomCrop = Math.max(0, Math.round(origCenterY - distBottom));

                // Convert back to 3-bit values
                const leftBits = Math.min(7, Math.round(leftCrop / baseUnit)) & 0x7;
                const rightBits = Math.min(7, Math.round(rightCrop / baseUnit)) & 0x7;
                const topBits = Math.min(7, Math.round(topCrop / baseUnit)) & 0x7;
                const bottomBits = Math.min(7, Math.round(bottomCrop / baseUnit)) & 0x7;

                // Reconstruct tracking ID
                const trackingId = (topBits << 9) | (rightBits << 6) | (bottomBits << 3) | leftBits;

                return {
                    trackingId,
                    details: {
                        widthRemoved: origWidth - currentWidth,
                        heightRemoved: origHeight - currentHeight,
                        centerDot: { x: dotX, y: dotY },
                        estimated: { top: topBits, right: rightBits, bottom: bottomBits, left: leftBits }
                    },
                    usedCenterDot: true
                };
            }

            // Fallback: estimate based on total removed (less accurate)
            const widthRemoved = origWidth - currentWidth;
            const heightRemoved = origHeight - currentHeight;

            // Assuming symmetric crop as fallback
            const leftCrop = Math.floor(widthRemoved / 2);
            const rightCrop = widthRemoved - leftCrop;
            const topCrop = Math.floor(heightRemoved / 2);
            const bottomCrop = heightRemoved - topCrop;

            // Convert back to 3-bit values
            const leftBits = Math.min(7, Math.round(leftCrop / baseUnit)) & 0x7;
            const rightBits = Math.min(7, Math.round(rightCrop / baseUnit)) & 0x7;
            const topBits = Math.min(7, Math.round(topCrop / baseUnit)) & 0x7;
            const bottomBits = Math.min(7, Math.round(bottomCrop / baseUnit)) & 0x7;

            // Reconstruct tracking ID
            const trackingId = (topBits << 9) | (rightBits << 6) | (bottomBits << 3) | leftBits;

            return {
                trackingId,
                details: {
                    widthRemoved,
                    heightRemoved,
                    estimated: { top: topBits, right: rightBits, bottom: bottomBits, left: leftBits }
                },
                usedCenterDot: false
            };
        }

        async function decodeVideo(file) {
            const video = document.createElement('video');
            video.src = URL.createObjectURL(file);

            await new Promise((resolve, reject) => {
                video.onloadedmetadata = resolve;
                video.onerror = reject;
            });

            const fps = 30;
            const duration = video.duration;
            const totalFrames = Math.floor(duration * fps);
            const currentWidth = video.videoWidth;
            const currentHeight = video.videoHeight;

            showStatus(`Video: ${currentWidth}x${currentHeight}, ${totalFrames} frames`, 'info');

            const canvas = document.createElement('canvas');
            canvas.width = currentWidth;
            canvas.height = currentHeight;
            const ctx = canvas.getContext('2d');

            // Calculate marker size (must match encoder)
            const markerScale = Math.max(1, Math.min(currentWidth, currentHeight) / 400);
            const cellSize = Math.floor(8 * markerScale);
            const markerWidth = cellSize * 7;
            const markerHeight = cellSize * 3;

            // Layer 1: Scan for markers in multiple frames
            const framesToScan = Math.min(30, totalFrames); // Scan first 30 frames
            const detectedValues = [];

            showStatus(`Scanning ${framesToScan} frames for markers...`, 'info');

            for (let i = 0; i < framesToScan; i++) {
                video.currentTime = i / fps;
                await new Promise(resolve => {
                    video.onseeked = resolve;
                });

                ctx.drawImage(video, 0, 0, currentWidth, currentHeight);
                const imageData = ctx.getImageData(0, 0, currentWidth, currentHeight);

                // Get expected marker position for this frame
                const expectedPos = getMarkerPosition(i, currentWidth, currentHeight, markerWidth, markerHeight);

                // Search around expected position (with some tolerance)
                const searchMargin = Math.floor(Math.min(currentWidth, currentHeight) * 0.1);
                const searchX = Math.max(0, expectedPos.x - searchMargin);
                const searchY = Math.max(0, expectedPos.y - searchMargin);
                const searchWidth = Math.min(currentWidth - searchX, markerWidth + 2 * searchMargin);
                const searchHeight = Math.min(currentHeight - searchY, markerHeight + 2 * searchMargin);

                const found = scanForFinderPattern(imageData, searchX, searchY, searchWidth, searchHeight, cellSize);

                if (found.score > 0.7) {
                    const bits = readMarkerData(imageData, found.x, found.y, cellSize);
                    const value = fromBinaryArray(bits);
                    detectedValues.push({ frame: i, value, bits, confidence: found.score });
                }

                if (i % 10 === 0) {
                    showStatus(`Scanning frames: ${i}/${framesToScan}`, 'info');
                }
            }

            // Layer 2: Edge crop detection with red center dot
            const origWidth = parseInt(origWidthInput.value) || null;
            const origHeight = parseInt(origHeightInput.value) || null;

            // Find red center dot from first frame
            showStatus('Looking for red center dot...', 'info');
            video.currentTime = 0;
            await new Promise(resolve => { video.onseeked = resolve; });
            ctx.drawImage(video, 0, 0, currentWidth, currentHeight);
            const firstFrameData = ctx.getImageData(0, 0, currentWidth, currentHeight);
            const centerDot = findRedCenterDot(firstFrameData);

            if (centerDot.found) {
                showStatus(`Red center dot found at (${centerDot.x}, ${centerDot.y})`, 'info');
            } else {
                showStatus('Red center dot not found, using fallback estimation', 'info');
            }

            const edgeCropResult = decodeFromEdgeCrop(currentWidth, currentHeight, origWidth, origHeight, centerDot);

            // Analyze results
            displayResults(detectedValues, edgeCropResult, currentWidth, currentHeight);
        }

        function displayResults(markerDetections, edgeCropResult, currentWidth, currentHeight) {
            detailsBody.innerHTML = '';

            let finalTrackingId = null;
            let finalConfidence = 'low';

            // Analyze marker detections
            if (markerDetections.length > 0) {
                // Find most common value
                const valueCounts = {};
                markerDetections.forEach(d => {
                    valueCounts[d.value] = (valueCounts[d.value] || 0) + 1;
                });

                let maxCount = 0;
                let mostCommon = null;
                for (const [value, count] of Object.entries(valueCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        mostCommon = parseInt(value);
                    }
                }

                const avgConfidence = markerDetections.reduce((sum, d) => sum + d.confidence, 0) / markerDetections.length;
                const consistency = maxCount / markerDetections.length;

                let markerConfidence = 'low';
                if (consistency > 0.8 && avgConfidence > 0.8) {
                    markerConfidence = 'high';
                } else if (consistency > 0.5 || avgConfidence > 0.7) {
                    markerConfidence = 'medium';
                }

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><span class="layer-badge layer-1">Layer 1</span> Marker Detection</td>
                    <td>${mostCommon} (detected in ${maxCount}/${markerDetections.length} frames)</td>
                    <td class="confidence-${markerConfidence}">${markerConfidence.toUpperCase()}</td>
                `;
                detailsBody.appendChild(row);

                if (markerConfidence !== 'low') {
                    finalTrackingId = mostCommon;
                    finalConfidence = markerConfidence;
                }

                // Show binary representation
                const binaryStr = mostCommon.toString(2).padStart(12, '0');
                binaryDisplay.textContent = `Binary: ${binaryStr} | Frames detected: ${markerDetections.length}`;
            } else {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><span class="layer-badge layer-1">Layer 1</span> Marker Detection</td>
                    <td>No markers found</td>
                    <td class="confidence-low">N/A</td>
                `;
                detailsBody.appendChild(row);
                binaryDisplay.textContent = 'No markers detected';
            }

            // Edge crop results
            if (edgeCropResult) {
                const centerDotInfo = edgeCropResult.usedCenterDot
                    ? ` | Center dot: (${edgeCropResult.details.centerDot.x}, ${edgeCropResult.details.centerDot.y})`
                    : '';
                const confidenceLevel = edgeCropResult.usedCenterDot ? 'high' : 'medium';
                const confidenceText = edgeCropResult.usedCenterDot ? 'HIGH (dot found)' : 'ESTIMATED';

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><span class="layer-badge layer-2">Layer 2</span> Edge Crop Analysis</td>
                    <td>${edgeCropResult.trackingId} (W: -${edgeCropResult.details.widthRemoved}px, H: -${edgeCropResult.details.heightRemoved}px${centerDotInfo})</td>
                    <td class="confidence-${confidenceLevel}">${confidenceText}</td>
                `;
                detailsBody.appendChild(row);

                // If marker detection failed, use edge crop
                if (finalTrackingId === null) {
                    finalTrackingId = edgeCropResult.trackingId;
                    finalConfidence = 'medium';
                }
                // If both methods found values, check if they match
                else if (finalTrackingId !== edgeCropResult.trackingId) {
                    const mismatchRow = document.createElement('tr');
                    mismatchRow.innerHTML = `
                        <td colspan="3" style="background: #fff3e0; color: #e65100;">
                            ⚠️ Layer mismatch: Marker=${finalTrackingId}, EdgeCrop=${edgeCropResult.trackingId}. Using marker result.
                        </td>
                    `;
                    detailsBody.appendChild(mismatchRow);
                } else {
                    finalConfidence = 'high';
                    const matchRow = document.createElement('tr');
                    matchRow.innerHTML = `
                        <td colspan="3" style="background: #e8f5e9; color: #2e7d32;">
                            ✓ Both layers agree! High confidence result.
                        </td>
                    `;
                    detailsBody.appendChild(matchRow);
                }
            } else {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td><span class="layer-badge layer-2">Layer 2</span> Edge Crop Analysis</td>
                    <td>Original dimensions not provided</td>
                    <td class="confidence-low">N/A</td>
                `;
                detailsBody.appendChild(row);
            }

            // Video info row
            const infoRow = document.createElement('tr');
            infoRow.innerHTML = `
                <td>Video Dimensions</td>
                <td>${currentWidth} x ${currentHeight}</td>
                <td>-</td>
            `;
            detailsBody.appendChild(infoRow);

            // Display final result
            if (finalTrackingId !== null) {
                trackingIdDisplay.textContent = finalTrackingId;
                resultBox.style.display = 'block';
                showStatus(`Tracking ID detected: ${finalTrackingId}`, 'success');
            } else {
                trackingIdDisplay.textContent = 'Not Found';
                resultBox.style.display = 'block';
                showStatus('Could not detect tracking ID. Video may not be watermarked or markers were removed.', 'error');
            }

            resultBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function showStatus(message, type = 'info') {
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }

        // ===== Manual Pattern Entry Modal =====
        const manualEntryBtn = document.getElementById('manualEntryBtn');
        const manualEntryModal = document.getElementById('manualEntryModal');
        const modalClose = document.getElementById('modalClose');
        const patternGrid = document.getElementById('patternGrid');
        const resetGridBtn = document.getElementById('resetGridBtn');
        const manualTrackingId = document.getElementById('manualTrackingId');
        const manualBinary = document.getElementById('manualBinary');

        // Grid state: 5x5 grid, center 3x3 is finder pattern
        // Finder pattern positions (row, col): (1,1), (1,2), (1,3), (2,1), (2,2), (2,3), (3,1), (3,2), (3,3)
        // Data bit positions (16 bits): all other cells
        const finderPattern = [
            [1, 1, 1],
            [1, 0, 1],
            [1, 1, 1]
        ];

        // Map grid positions to data bit indices
        // Layout:
        // [0 ][1 ][2 ][3 ][4 ]   <- row 0: bits 0-4
        // [5 ][F ][F ][F ][6 ]   <- row 1: bits 5, 6
        // [7 ][F ][F ][F ][8 ]   <- row 2: bits 7, 8
        // [9 ][F ][F ][F ][10]   <- row 3: bits 9, 10
        // [11][12][13][14][15]   <- row 4: bits 11-15
        const dataBitMap = {};
        let bitIndex = 0;
        for (let row = 0; row < 5; row++) {
            for (let col = 0; col < 5; col++) {
                const isFinderCell = row >= 1 && row <= 3 && col >= 1 && col <= 3;
                if (!isFinderCell) {
                    dataBitMap[`${row}-${col}`] = bitIndex++;
                }
            }
        }

        // Store data bit states (16 bits)
        let dataBits = new Array(16).fill(0);

        // Build the grid
        function buildGrid() {
            patternGrid.innerHTML = '';

            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const isFinderCell = row >= 1 && row <= 3 && col >= 1 && col <= 3;

                    if (isFinderCell) {
                        // Finder pattern cell (fixed)
                        cell.classList.add('finder');
                        const finderRow = row - 1;
                        const finderCol = col - 1;
                        const isActive = finderPattern[finderRow][finderCol] === 1;
                        cell.classList.add(isActive ? 'active' : 'inactive');
                        cell.textContent = 'F';
                    } else {
                        // Data bit cell (clickable)
                        const bitIdx = dataBitMap[`${row}-${col}`];
                        cell.dataset.bitIndex = bitIdx;
                        cell.textContent = bitIdx;

                        if (dataBits[bitIdx] === 1) {
                            cell.classList.add('active');
                        }

                        cell.addEventListener('click', () => toggleDataBit(cell, bitIdx));
                    }

                    patternGrid.appendChild(cell);
                }
            }
        }

        // Toggle a data bit
        function toggleDataBit(cell, bitIndex) {
            dataBits[bitIndex] = dataBits[bitIndex] === 0 ? 1 : 0;
            cell.classList.toggle('active');
            updateManualResult();
        }

        // Update the decoded result
        function updateManualResult() {
            // Convert 16 bits to tracking ID
            let trackingId = 0;
            for (let i = 0; i < 16; i++) {
                trackingId = (trackingId << 1) | dataBits[i];
            }

            manualTrackingId.textContent = trackingId;
            const binaryStr = dataBits.join('');
            manualBinary.textContent = `Binary: ${binaryStr}`;
        }

        // Reset the grid
        function resetGrid() {
            dataBits = new Array(16).fill(0);
            buildGrid();
            updateManualResult();
        }

        // Open modal
        manualEntryBtn.addEventListener('click', () => {
            manualEntryModal.classList.add('active');
            buildGrid();
            updateManualResult();
        });

        // Close modal
        modalClose.addEventListener('click', () => {
            manualEntryModal.classList.remove('active');
        });

        // Close modal on overlay click
        manualEntryModal.addEventListener('click', (e) => {
            if (e.target === manualEntryModal) {
                manualEntryModal.classList.remove('active');
            }
        });

        // Reset button
        resetGridBtn.addEventListener('click', resetGrid);

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && manualEntryModal.classList.contains('active')) {
                manualEntryModal.classList.remove('active');
            }
        });
    </script>
</body>
</html>
