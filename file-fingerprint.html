<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Transform Fingerprint Lab (A + B -> C; A + C -> B)</title>
  <style>
    :root{
      --bg:#0b1220;
      --card:#0f1b33;
      --muted:#a7b3cc;
      --text:#e9eefc;
      --border:rgba(255,255,255,.10);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      background: radial-gradient(1200px 700px at 20% -10%, rgba(125,211,252,.18), transparent 60%),
                  radial-gradient(1000px 600px at 120% 20%, rgba(167,139,250,.16), transparent 55%),
                  linear-gradient(180deg, #070b14, var(--bg));
      color:var(--text);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:22px;}
    h1{margin:0 0 6px;font-size:20px;letter-spacing:.2px;}
    p{margin:6px 0 0;color:var(--muted);line-height:1.35}
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:16px;
    }
    @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
    label{font-size:12px;color:var(--muted);display:block;margin:10px 0 6px}
    input[type="file"], input[type="number"], input[type="text"], textarea, select{
      background: rgba(0,0,0,.25);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:12px;
      padding:10px 10px;
      outline:none;
    }
    input[type="number"], input[type="text"], select{height:40px;}
    textarea{width:100%;min-height:110px;resize:vertical}
    .btn{
      appearance:none;border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(125,211,252,.20), rgba(125,211,252,.08));
      color:var(--text);
      padding:10px 12px;border-radius:12px;
      cursor:pointer;
      font-weight:650;
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}
    .btn.secondary{
      background: linear-gradient(180deg, rgba(167,139,250,.18), rgba(167,139,250,.07));
    }
    .btn.ghost{
      background: rgba(0,0,0,.18);
    }
    .small{font-size:12px;color:var(--muted)}
    .previews{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 540px){ .previews{grid-template-columns:1fr;} }
    canvas.preview{
      width:100%;
      background: rgba(0,0,0,.28);
      border:1px solid var(--border);
      border-radius:14px;
      image-rendering: auto;
    }
    .kpi{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.20);
      font-size:12px;color:var(--muted);
    }
    .pill b{color:var(--text);font-size:12px}
    .pill.good b{color:var(--good)}
    .pill.warn b{color:var(--warn)}
    .pill.bad b{color:var(--bad)}
    .results{
      margin-top:10px;
      border-top:1px dashed var(--border);
      padding-top:10px;
    }
    .results ol{margin:8px 0 0 18px;color:var(--muted)}
    .results li{margin:4px 0}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .sliderRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input[type="range"]{width:220px}
    .warnBox{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(251,191,36,.35);
      background: rgba(251,191,36,.08);
      color: rgba(251,191,36,.95);
      font-size:12px;
      line-height:1.35;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Image Transform Fingerprint Lab</h1>
    <p>
      Encode: upload <b>A</b>, enter tracking number <b>B</b>, pick a manipulation → get downloadable <b>C</b>.<br/>
      Decode: upload <b>A</b> + leaked/downloaded <b>C</b>, test candidate <b>B</b> values → correlation ranks likely leaker.
    </p>

    <div class="grid">
      <!-- ENCODE -->
      <div class="card">
        <h2 style="margin:0 0 8px;font-size:16px">1) Encoder (A + B → C)</h2>

        <div class="row">
          <div style="flex:1;min-width:240px">
            <label>Upload Image A (original)</label>
            <input id="encA" type="file" accept="image/*" />
          </div>
          <div style="width:220px">
            <label>Number B (tracking ID)</label>
            <input id="encB" type="number" value="12345" min="0" step="1" />
          </div>
          <div style="flex:1;min-width:240px">
            <label>Manipulation</label>
            <select id="encMode">
              <option value="rotCrop">rotation + crop</option>
              <option value="shiftCrop">shift + crop</option>
              <option value="scaleX">X-scale (linear)</option>
              <option value="scaleY">Y-scale (linear)</option>
              <option value="logX">X-scale (logarithmic)</option>
              <option value="logY">Y-scale (logarithmic)</option>
              <option value="fisheye">fish-eye dilation</option>
              <option value="aberration">chromatic aberration angles</option>
              <option value="colorShift">color shift (HSV-ish)</option>
              <option value="contrastShift">contrast shift</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:6px">
          <div style="flex:1;min-width:280px">
            <label>Intensity (affects transform magnitude)</label>
            <div class="sliderRow">
              <input id="encIntensity" type="range" min="0" max="100" value="55" />
              <span class="pill"><span class="small">value</span> <b id="encIntensityVal">55</b></span>
              <button class="btn ghost" id="randB" type="button">Random B</button>
            </div>
          </div>
          <div style="display:flex;gap:10px;align-items:end">
            <button class="btn" id="btnEncode" type="button" disabled>Generate C</button>
            <button class="btn secondary" id="btnDownload" type="button" disabled>Download C</button>
          </div>
        </div>

        <div class="previews">
          <div>
            <label>Preview A</label>
            <canvas id="canA" class="preview" width="640" height="360"></canvas>
          </div>
          <div>
            <label>Preview C (encoded)</label>
            <canvas id="canC" class="preview" width="640" height="360"></canvas>
          </div>
        </div>

        <div class="kpi">
          <span class="pill"><span class="small">A size</span> <b id="aSize">—</b></span>
          <span class="pill"><span class="small">C size</span> <b id="cSize">—</b></span>
          <span class="pill"><span class="small">mode</span> <b id="modeEcho">—</b></span>
        </div>

        <div class="warnBox">
          Tip: For “real” tracking you’ll usually want transforms small enough to be imperceptible,
          but still measurable after re-encode. Use this page to see which modes keep correlation separable.
        </div>
      </div>

      <!-- DECODE -->
      <div class="card">
        <h2 style="margin:0 0 8px;font-size:16px">2) Decoder (A + C → best B)</h2>

        <div class="row">
          <div style="flex:1;min-width:240px">
            <label>Upload Image A (original)</label>
            <input id="decA" type="file" accept="image/*" />
          </div>
          <div style="flex:1;min-width:240px">
            <label>Upload Image C (downloaded/leaked)</label>
            <input id="decC" type="file" accept="image/*" />
          </div>
          <div style="flex:1;min-width:240px">
            <label>Manipulation (must match encoder)</label>
            <select id="decMode">
              <option value="rotCrop">rotation + crop</option>
              <option value="shiftCrop">shift + crop</option>
              <option value="scaleX">X-scale (linear)</option>
              <option value="scaleY">Y-scale (linear)</option>
              <option value="logX">X-scale (logarithmic)</option>
              <option value="logY">Y-scale (logarithmic)</option>
              <option value="fisheye">fish-eye dilation</option>
              <option value="aberration">chromatic aberration angles</option>
              <option value="colorShift">color shift (HSV-ish)</option>
              <option value="contrastShift">contrast shift</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:6px">
          <div style="flex:1;min-width:280px">
            <label>Candidate B values (comma / space / newline separated)</label>
            <textarea id="candidates" class="mono" placeholder="Example:
12345
12346
20001,20002,20003"></textarea>
          </div>
        </div>

        <div class="row" style="margin-top:6px">
          <div style="flex:1;min-width:280px">
            <label>Or brute force range (small ranges only)</label>
            <div class="row">
              <div>
                <input id="bfStart" type="number" value="12340" step="1" />
                <div class="small">start</div>
              </div>
              <div>
                <input id="bfEnd" type="number" value="12360" step="1" />
                <div class="small">end (inclusive)</div>
              </div>
              <div>
                <input id="bfStep" type="number" value="1" step="1" min="1" />
                <div class="small">step</div>
              </div>
              <button class="btn ghost" id="fillRange" type="button">Fill candidates from range</button>
            </div>
          </div>

          <div style="flex:1;min-width:280px">
            <label>Decoder options</label>
            <div class="row">
              <div>
                <select id="downsample">
                  <option value="64">Downsample 64×64 (fast)</option>
                  <option value="96">Downsample 96×96</option>
                  <option value="128" selected>Downsample 128×128 (best)</option>
                </select>
                <div class="small">correlation grid</div>
              </div>
              <div>
                <input id="decIntensity" type="number" value="55" min="0" max="100" step="1" />
                <div class="small">intensity (must match)</div>
              </div>
              <div style="display:flex;gap:10px;align-items:end">
                <button class="btn" id="btnDecode" type="button" disabled>Try candidates</button>
              </div>
            </div>
          </div>
        </div>

        <div class="previews">
          <div>
            <label>Decoder: A</label>
            <canvas id="canDA" class="preview" width="640" height="360"></canvas>
          </div>
          <div>
            <label>Decoder: best aligned C → A (using best B)</label>
            <canvas id="canAligned" class="preview" width="640" height="360"></canvas>
          </div>
        </div>

        <div class="kpi">
          <span class="pill"><span class="small">best B</span> <b id="bestB">—</b></span>
          <span class="pill good"><span class="small">best score</span> <b id="bestScore">—</b></span>
          <span class="pill"><span class="small">tested</span> <b id="testedN">0</b></span>
          <span class="pill"><span class="small">time</span> <b id="timeMs">—</b></span>
        </div>

        <div class="results">
          <div class="small">Top matches (higher is more similar)</div>
          <ol id="ranked"></ol>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Utilities: seeded PRNG, parsing, image load, sampling
   ========================================================= */

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ (t >>> 15), 1 | t);
    x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}

function seedFromInt(n){
  // mix integer into 32-bit seed
  let x = (Number(n) >>> 0);
  x ^= x << 13; x >>>= 0;
  x ^= x >>> 17; x >>>= 0;
  x ^= x << 5;  x >>>= 0;
  return x >>> 0;
}

function parseCandidates(text){
  const parts = text
    .replace(/[#].*$/gm,'') // allow comments starting with #
    .split(/[\s,]+/g)
    .map(s => s.trim())
    .filter(Boolean);
  const nums = [];
  for(const p of parts){
    const v = Number(p);
    if(Number.isFinite(v)) nums.push(Math.floor(v));
  }
  // de-dup preserving order
  const seen = new Set();
  const out = [];
  for(const v of nums){
    const k = String(v);
    if(!seen.has(k)){ seen.add(k); out.push(v); }
  }
  return out;
}

async function fileToImage(file){
  const url = URL.createObjectURL(file);
  try{
    const img = new Image();
    img.decoding = "async";
    img.src = url;
    await img.decode();
    return img;
  } finally {
    // Keep URL until decode done; release later if you want.
    // URL.revokeObjectURL(url);
  }
}

function fitCanvasToImage(canvas, img, maxW=1200, maxH=900){
  const w = img.naturalWidth || img.width;
  const h = img.naturalHeight || img.height;
  const s = Math.min(maxW / w, maxH / h, 1);
  canvas.width = Math.max(1, Math.round(w * s));
  canvas.height = Math.max(1, Math.round(h * s));
  return {w: canvas.width, h: canvas.height, scale: s};
}

function drawImageToCanvas(canvas, img){
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
}

function getImageData(canvas){
  const ctx = canvas.getContext("2d");
  return ctx.getImageData(0,0,canvas.width,canvas.height);
}

function putImageData(canvas, imgData){
  const ctx = canvas.getContext("2d");
  ctx.putImageData(imgData, 0,0);
}

function sampleBilinear(src, x, y){
  // src: ImageData, x,y in source pixel coords
  const w = src.width, h = src.height;
  if(x < 0 || y < 0 || x > w-1 || y > h-1) return [0,0,0,0];

  const x0 = Math.floor(x), y0 = Math.floor(y);
  const x1 = Math.min(x0+1, w-1), y1 = Math.min(y0+1, h-1);
  const dx = x - x0, dy = y - y0;

  const idx = (xx,yy)=> (yy*w+xx)*4;
  const p00 = idx(x0,y0), p10 = idx(x1,y0), p01 = idx(x0,y1), p11 = idx(x1,y1);

  const d = src.data;
  const out = [0,0,0,0];
  for(let c=0;c<4;c++){
    const v00 = d[p00+c], v10 = d[p10+c], v01 = d[p01+c], v11 = d[p11+c];
    const v0 = v00*(1-dx) + v10*dx;
    const v1 = v01*(1-dx) + v11*dx;
    out[c] = v0*(1-dy) + v1*dy;
  }
  return out;
}

function rgbToLuma(r,g,b){
  // Rec.709-ish
  return 0.2126*r + 0.7152*g + 0.0722*b;
}

/* =========================================================
   Transform parameterization from B + intensity
   ========================================================= */

function paramsFromB(mode, B, intensity){
  const seed = seedFromInt(B);
  const rnd = mulberry32(seed);

  const t = clamp(intensity/100, 0, 1);

  // Keep transforms subtle by default; intensity scales magnitudes.
  // You can increase these if you want more separation at cost of visibility.
  const p = { mode, B, intensity };

  if(mode === "rotCrop"){
    const sign = rnd() < 0.5 ? -1 : 1;
    const angleDeg = sign * (0.15 + 1.85 * t) * (0.35 + 0.65*rnd()); // ~0.05..2 deg
    const crop = (0.02 + 0.06*t) * (0.4 + 0.6*rnd()); // crop margin fraction
    p.angle = angleDeg * Math.PI/180;
    p.crop = crop;
  } else if(mode === "shiftCrop"){
    const maxShift = (2 + 18*t) * (0.4 + 0.6*rnd()); // px in preview space
    const dx = (rnd()*2-1)*maxShift;
    const dy = (rnd()*2-1)*maxShift;
    const crop = (0.01 + 0.05*t) * (0.4 + 0.6*rnd());
    p.dx = dx; p.dy = dy; p.crop = crop;
  } else if(mode === "scaleXY"){
    // Linear scale factors
    const sx = 1 + (rnd()*2-1) * (0.002 + 0.02*t);
    const sy = 1 + (rnd()*2-1) * (0.002 + 0.02*t);
    // Logarithmic warp factors for both X and Y
    const kx = (rnd()<0.5?-1:1) * (0.01 + 0.10*t) * (0.4 + 0.6*rnd());
    const ky = (rnd()<0.5?-1:1) * (0.01 + 0.10*t) * (0.4 + 0.6*rnd());
    p.sx = sx; p.sy = sy;
    p.kx = kx; p.ky = ky;
  } else if(mode === "logX"){
    p.k = (rnd()<0.5?-1:1) * (0.02 + 0.18*t) * (0.4 + 0.6*rnd()); // curvature strength
  } else if(mode === "logY"){
    p.k = (rnd()<0.5?-1:1) * (0.02 + 0.18*t) * (0.4 + 0.6*rnd());
  } else if(mode === "fisheye"){
    p.k = (rnd()<0.5?-1:1) * (0.03 + 0.22*t) * (0.4 + 0.6*rnd()); // radial distortion strength
  } else if(mode === "aberration"){
    // tiny RGB radial offsets (in pixels, relative to radius)
    p.k = (0.6 + 1.8*t) * (0.4 + 0.6*rnd());
    p.angle = (rnd()*2-1) * Math.PI; // direction
  } else if(mode === "colorShift"){
    p.h = (rnd()*2-1) * (0.5 + 6*t);   // degrees-ish (we'll approximate)
    p.s = (rnd()*2-1) * (0.01 + 0.10*t);
    p.v = (rnd()*2-1) * (0.01 + 0.10*t);
  } else if(mode === "contrastShift"){
    p.c = 1 + (rnd()*2-1) * (0.01 + 0.18*t); // contrast multiplier
    p.b = (rnd()*2-1) * (1 + 12*t); // brightness shift (0..~12)
  } else {
    throw new Error("Unknown mode: " + mode);
  }
  return p;
}

/* =========================================================
   Warp / Transform core
   We implement inverse-mapping: for each output pixel, sample source.
   Also provide applyInverse flag for decoding alignment.
   ========================================================= */

function warpImage(srcImgData, params, applyInverse=false){
  const w = srcImgData.width, h = srcImgData.height;
  const out = new ImageData(w, h);
  const cx = (w-1)/2, cy = (h-1)/2;

  function mapCoord(xo, yo){
    // returns [xs, ys] where we sample from src
    const x = xo - cx, y = yo - cy;

    const m = params.mode;

    if(m === "rotCrop"){
      const ang = applyInverse ? -params.angle : params.angle;
      const ca = Math.cos(ang), sa = Math.sin(ang);
      const xr = x*ca - y*sa;
      const yr = x*sa + y*ca;

      // crop by scaling up slightly (center crop)
      const crop = params.crop || 0;
      const s = 1 / (1 - crop); // enlarge content to simulate crop
      const xs = xr * s + cx;
      const ys = yr * s + cy;
      return [xs, ys];
    }

    if(m === "shiftCrop"){
      const dx = applyInverse ? -params.dx : params.dx;
      const dy = applyInverse ? -params.dy : params.dy;
      const crop = params.crop || 0;
      const s = 1 / (1 - crop);
      const xs = (x + dx) * s + cx;
      const ys = (y + dy) * s + cy;
      return [xs, ys];
    }

    if(m === "scaleXY"){
      const sx = params.sx, sy = params.sy;
      const invSx = 1/sx, invSy = 1/sy;
      const xs = (applyInverse ? x*sx : x*invSx) + cx;
      const ys = (applyInverse ? y*sy : y*invSy) + cy;
      // Explanation:
      // - Encoding: output is "warped" so sample from smaller/larger region.
      // - Decoding alignment: we flip mapping direction with applyInverse.
      return [xs, ys];
    }

    if(m === "logX"){
      // non-constant scale in x as a function of normalized x
      // map: xs = x + k * sign(x) * log(1 + a*|x|) ; use normalized by width
      const k = applyInverse ? -params.k : params.k;
      const nx = x / (w/2);
      const a = 3.0;
      const warp = k * Math.sign(nx) * Math.log(1 + a*Math.abs(nx));
      const xs = (x + warp*(w/2)) + cx;
      const ys = y + cy;
      return [xs, ys];
    }

    if(m === "logY"){
      const k = applyInverse ? -params.k : params.k;
      const ny = y / (h/2);
      const a = 3.0;
      const warp = k * Math.sign(ny) * Math.log(1 + a*Math.abs(ny));
      const xs = x + cx;
      const ys = (y + warp*(h/2)) + cy;
      return [xs, ys];
    }

    if(m === "fisheye"){
      // simple radial distortion: r' = r*(1 + k*r^2)
      const k = applyInverse ? -params.k : params.k;
      const rx = x/(w/2), ry = y/(h/2);
      const r2 = rx*rx + ry*ry;
      const scale = 1 + k*r2;
      const xs = (x * scale) + cx;
      const ys = (y * scale) + cy;
      return [xs, ys];
    }

    // Color-only modes don't change coords
    return [xo, yo];
  }

  // For chromatic aberration, we do per-channel coord offsets
  function mapCoordRGB(xo, yo){
    const x = xo - cx, y = yo - cy;
    const m = params.mode;
    if(m !== "aberration") return null;

    const k = params.k || 1.0;
    const ang = params.angle || 0;

    const rx = x/(w/2), ry = y/(h/2);
    const r = Math.sqrt(rx*rx + ry*ry);
    const ux = Math.cos(ang), uy = Math.sin(ang);

    // Offsets are subtle, scale by r^1.2 so it grows near edges.
    // Apply inverse by negating.
    const sgn = applyInverse ? -1 : 1;
    const base = sgn * k * Math.pow(r, 1.2);
    const ox = base * ux;
    const oy = base * uy;

    // Different offsets per channel (R/G/B)
    return {
      r: [x + ox*2.0 + cx, y + oy*2.0 + cy],
      g: [x + ox*1.0 + cx, y + oy*1.0 + cy],
      b: [x + ox*0.0 + cx, y + oy*0.0 + cy]
    };
  }

  // Pixel loop
  const src = srcImgData;
  const od = out.data;

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = (y*w + x)*4;

      if(params.mode === "aberration"){
        const c = mapCoordRGB(x,y);
        const pr = sampleBilinear(src, c.r[0], c.r[1]);
        const pg = sampleBilinear(src, c.g[0], c.g[1]);
        const pb = sampleBilinear(src, c.b[0], c.b[1]);
        od[idx+0] = pr[0];
        od[idx+1] = pg[1];
        od[idx+2] = pb[2];
        od[idx+3] = 255;
        continue;
      }

      const [xs, ys] = mapCoord(x,y);
      const p = sampleBilinear(src, xs, ys);

      od[idx+0] = p[0];
      od[idx+1] = p[1];
      od[idx+2] = p[2];
      od[idx+3] = 255;
    }
  }

  // Apply color-only transforms after warp
  if(params.mode === "colorShift"){
    applyColorShiftInPlace(out, params, applyInverse);
  } else if(params.mode === "contrastShift"){
    applyContrastShiftInPlace(out, params, applyInverse);
  }

  return out;
}

/* =========================================================
   Color transforms (simple + fast approximations)
   ========================================================= */

function applyContrastShiftInPlace(imgData, params, applyInverse){
  const d = imgData.data;
  const c = params.c ?? 1.0;
  const b = params.b ?? 0.0;

  // Inverse roughly undoes it
  const cc = applyInverse ? (1 / c) : c;
  const bb = applyInverse ? (-b) : b;

  for(let i=0;i<d.length;i+=4){
    for(let ch=0; ch<3; ch++){
      const v = d[i+ch];
      const vv = (v - 128) * cc + 128 + bb;
      d[i+ch] = clamp(vv, 0, 255);
    }
  }
}

function applyColorShiftInPlace(imgData, params, applyInverse){
  // We'll do a lightweight "HSV-ish" shift:
  // - approximate hue rotation by rotating RGB in a luma-preserving space (not perfect HSV).
  // - s/v as small multipliers.
  const d = imgData.data;
  const hDeg = params.h ?? 0;
  const s = params.s ?? 0;
  const v = params.v ?? 0;

  const hh = (applyInverse ? -hDeg : hDeg) * Math.PI/180;
  const ss = applyInverse ? -s : s;
  const vv = applyInverse ? -v : v;

  // Hue rotation matrix around luma axis (approx).
  const cosA = Math.cos(hh), sinA = Math.sin(hh);
  // coefficients adapted from common "hue rotate" approximations
  const lumR=0.213, lumG=0.715, lumB=0.072;

  const a00 = lumR + cosA*(1-lumR) + sinA*(-lumR);
  const a01 = lumG + cosA*(-lumG) + sinA*(-lumG);
  const a02 = lumB + cosA*(-lumB) + sinA*(1-lumB);

  const a10 = lumR + cosA*(-lumR) + sinA*(0.143);
  const a11 = lumG + cosA*(1-lumG) + sinA*(0.140);
  const a12 = lumB + cosA*(-lumB) + sinA*(-0.283);

  const a20 = lumR + cosA*(-lumR) + sinA*(-(1-lumR));
  const a21 = lumG + cosA*(-lumG) + sinA*(lumG);
  const a22 = lumB + cosA*(1-lumB) + sinA*(lumB);

  const sat = 1 + ss;
  const val = 1 + vv;

  for(let i=0;i<d.length;i+=4){
    let r=d[i], g=d[i+1], b=d[i+2];
    const rr = a00*r + a01*g + a02*b;
    const gg = a10*r + a11*g + a12*b;
    const bb = a20*r + a21*g + a22*b;

    // saturation-ish: push away from luma
    const y = rgbToLuma(rr,gg,bb);
    r = y + (rr - y)*sat;
    g = y + (gg - y)*sat;
    b = y + (bb - y)*sat;

    // value-ish
    r *= val; g *= val; b *= val;

    d[i]   = clamp(r,0,255);
    d[i+1] = clamp(g,0,255);
    d[i+2] = clamp(b,0,255);
  }
}

/* =========================================================
   Similarity (Normalized Cross-Correlation on grayscale)
   ========================================================= */

function downsampleToGray(imgData, N){
  // returns Float32Array length N*N, values zero-mean not applied yet
  const w = imgData.width, h = imgData.height;
  const out = new Float32Array(N*N);
  const sx = w / N, sy = h / N;
  const d = imgData.data;

  for(let j=0;j<N;j++){
    for(let i=0;i<N;i++){
      // sample at cell center
      const x = (i + 0.5) * sx;
      const y = (j + 0.5) * sy;
      const p = sampleBilinear(imgData, x, y);
      out[j*N+i] = rgbToLuma(p[0],p[1],p[2]) / 255;
    }
  }
  return out;
}

function ncc(a, b){
  // normalized cross correlation of two Float32 arrays
  const n = a.length;
  let meanA=0, meanB=0;
  for(let i=0;i<n;i++){ meanA += a[i]; meanB += b[i]; }
  meanA/=n; meanB/=n;

  let num=0, denA=0, denB=0;
  for(let i=0;i<n;i++){
    const da = a[i]-meanA;
    const db = b[i]-meanB;
    num += da*db;
    denA += da*da;
    denB += db*db;
  }
  const den = Math.sqrt(denA*denB) + 1e-12;
  return num/den;
}

/* =========================================================
   App state + UI wiring
   ========================================================= */

const enc = {
  imgA: null,
  imgDataA: null,
  imgDataC: null,
};

const dec = {
  imgA: null,
  imgC: null,
  imgDataA: null,
  imgDataC: null,
};

const $ = (id)=>document.getElementById(id);

const canA = $("canA");
const canC = $("canC");
const canDA = $("canDA");
const canAligned = $("canAligned");

$("encIntensity").addEventListener("input", ()=>{
  $("encIntensityVal").textContent = $("encIntensity").value;
});

$("randB").addEventListener("click", ()=>{
  const r = Math.floor(Math.random() * 1e9);
  $("encB").value = r;
});

$("encA").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  enc.imgA = await fileToImage(f);
  fitCanvasToImage(canA, enc.imgA, 1200, 900);
  fitCanvasToImage(canC, enc.imgA, 1200, 900);
  drawImageToCanvas(canA, enc.imgA);
  enc.imgDataA = getImageData(canA);

  $("aSize").textContent = `${enc.imgDataA.width}×${enc.imgDataA.height}`;
  $("btnEncode").disabled = false;
  $("modeEcho").textContent = $("encMode").value;
});

$("encMode").addEventListener("change", ()=>{
  $("modeEcho").textContent = $("encMode").value;
});

$("btnEncode").addEventListener("click", ()=>{
  if(!enc.imgDataA) return;
  const mode = $("encMode").value;
  const B = Number($("encB").value || 0);
  const intensity = Number($("encIntensity").value || 0);

  const params = paramsFromB(mode, B, intensity);
  const out = warpImage(enc.imgDataA, params, false);
  enc.imgDataC = out;

  putImageData(canC, out);
  $("cSize").textContent = `${out.width}×${out.height}`;
  $("btnDownload").disabled = false;
});

$("btnDownload").addEventListener("click", ()=>{
  if(!enc.imgDataC) return;
  const a = document.createElement("a");
  const mode = $("encMode").value;
  const B = $("encB").value;
  a.download = `C_${mode}_B${B}.png`;
  a.href = canC.toDataURL("image/png");
  a.click();
});

$("fillRange").addEventListener("click", ()=>{
  const s = Math.floor(Number($("bfStart").value || 0));
  const e = Math.floor(Number($("bfEnd").value || 0));
  const step = Math.max(1, Math.floor(Number($("bfStep").value || 1)));
  const lo = Math.min(s,e), hi = Math.max(s,e);

  const vals = [];
  for(let v=lo; v<=hi; v+=step) vals.push(v);
  $("candidates").value = vals.join("\n");
});

$("decA").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  dec.imgA = await fileToImage(f);
  fitCanvasToImage(canDA, dec.imgA, 1200, 900);
  drawImageToCanvas(canDA, dec.imgA);
  dec.imgDataA = getImageData(canDA);
  updateDecodeReady();
});

$("decC").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  if(!f) return;
  dec.imgC = await fileToImage(f);

  // Make aligned canvas match A canvas size for consistent compare
  if(dec.imgDataA){
    canAligned.width = canDA.width;
    canAligned.height = canDA.height;
  } else {
    fitCanvasToImage(canAligned, dec.imgC, 1200, 900);
  }
  const ctx = canAligned.getContext("2d");
  ctx.clearRect(0,0,canAligned.width,canAligned.height);
  ctx.drawImage(dec.imgC, 0, 0, canAligned.width, canAligned.height);

  dec.imgDataC = getImageData(canAligned);
  updateDecodeReady();
});

function updateDecodeReady(){
  $("btnDecode").disabled = !(dec.imgDataA && dec.imgDataC);
}

$("btnDecode").addEventListener("click", async ()=>{
  if(!(dec.imgDataA && dec.imgDataC)) return;

  const mode = $("decMode").value;
  const intensity = Number($("decIntensity").value || 0);
  const N = Number($("downsample").value || 128);

  const candidates = parseCandidates($("candidates").value);
  if(candidates.length === 0){
    alert("Provide some candidate B values (or use 'Fill candidates from range').");
    return;
  }

  $("testedN").textContent = "0";
  $("bestB").textContent = "—";
  $("bestScore").textContent = "—";
  $("timeMs").textContent = "—";
  $("ranked").innerHTML = "";

  const t0 = performance.now();

  // Precompute A downsample
  const Agray = downsampleToGray(dec.imgDataA, N);

  // We'll test each candidate by "undoing" transform on C and correlating with A
  const scores = [];

  // Use a scratch ImageData to avoid realloc in tight loop
  // (Still returns new ImageData from warpImage; you can optimize further if needed)
  for(let i=0;i<candidates.length;i++){
    const B = candidates[i];
    const params = paramsFromB(mode, B, intensity);

    // Align: apply inverse transform to C (so it should resemble A)
    const aligned = warpImage(dec.imgDataC, params, true);
    const Cgray = downsampleToGray(aligned, N);
    const score = ncc(Agray, Cgray);

    scores.push({B, score, aligned});
    $("testedN").textContent = String(i+1);

    // Yield to UI occasionally
    if((i % 15) === 14) await new Promise(r=>setTimeout(r,0));
  }

  scores.sort((a,b)=> b.score - a.score);
  const best = scores[0];

  const t1 = performance.now();
  $("bestB").textContent = String(best.B);
  $("bestScore").textContent = best.score.toFixed(6);
  $("timeMs").textContent = `${Math.round(t1 - t0)} ms`;

  // Show best aligned
  putImageData(canAligned, best.aligned);

  // Show top 10
  const topK = Math.min(10, scores.length);
  const ol = $("ranked");
  for(let i=0;i<topK;i++){
    const it = scores[i];
    const li = document.createElement("li");
    li.innerHTML = `<span class="mono">B=${it.B}</span> — score <span class="mono">${it.score.toFixed(6)}</span>`;
    ol.appendChild(li);
  }
});

</script>
</body>
</html>
