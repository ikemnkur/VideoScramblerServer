<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Watermark Decoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a252f 0%, #2980b9 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #1a252f;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="file"],
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:hover {
            border-color: #2980b9;
        }

        input:focus {
            outline: none;
            border-color: #2980b9;
        }

        .options-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .options-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        button {
            background: linear-gradient(135deg, #1a252f 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(41, 128, 185, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            border-left: 4px solid #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .result-box {
            margin-top: 30px;
            padding: 30px;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            border-radius: 12px;
            text-align: center;
            display: none;
        }

        .result-box h2 {
            color: white;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .tracking-id {
            font-size: 56px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            padding: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin: 15px 0;
        }

        .binary-display {
            font-family: monospace;
            background: #1a252f;
            color: #2ecc71;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 14px;
        }

        .details {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            text-align: left;
        }

        .details h3 {
            color: #2c3e50;
            margin-bottom: 12px;
            font-size: 16px;
        }

        .details table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .details th,
        .details td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .details th {
            background: #f5f5f5;
            font-weight: 600;
            color: #555;
        }

        .confidence-high {
            color: #388e3c;
            font-weight: bold;
        }

        .confidence-medium {
            color: #f57c00;
            font-weight: bold;
        }

        .confidence-low {
            color: #c62828;
            font-weight: bold;
        }

        .preview-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .preview-box {
            flex: 1;
            min-width: 250px;
        }

        .preview-box h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .preview-box img,
        .preview-box canvas {
            max-width: 100%;
            max-height: 250px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            display: block;
        }

        .info-box {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #555;
        }

        .info-box h3 {
            color: #1a252f;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .info-box ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .info-box li {
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Photo Watermark Decoder</h1>
        <p class="subtitle">Extract tracking ID from watermarked photo by detecting center dot and measuring edges</p>

        <div class="input-group">
            <label for="imageFile">Select Watermarked Image:</label>
            <input type="file" id="imageFile" accept="image/*">
        </div>

        <div class="options-row">
            <div class="input-group">
                <label for="origWidth">Original Width (pixels):</label>
                <input type="number" id="origWidth" placeholder="e.g., 1920">
            </div>
            <div class="input-group">
                <label for="origHeight">Original Height (pixels):</label>
                <input type="number" id="origHeight" placeholder="e.g., 1080">
            </div>
        </div>

        <button id="decodeBtn">Decode Watermark</button>

        <div id="status"></div>

        <div class="preview-container" id="previewContainer" style="display: none;">
            <div class="preview-box">
                <h3>Watermarked Image:</h3>
                <img id="imagePreview" alt="Watermarked">
            </div>
            <div class="preview-box">
                <h3>Center Dot Detection:</h3>
                <canvas id="detectionCanvas"></canvas>
            </div>
        </div>

        <div class="result-box" id="resultBox">
            <h2>Tracking ID Detected</h2>
            <div class="tracking-id" id="trackingIdDisplay">-</div>
            <div class="binary-display" id="binaryDisplay"></div>
            <div class="details">
                <h3>Detection Details:</h3>
                <table>
                    <tbody id="detailsBody">
                    </tbody>
                </table>
            </div>
        </div>

        <div class="info-box">
            <h3>Decoding Process:</h3>
            <ul>
                <li><strong>Step 1:</strong> Scan image for red center dot (high R, low G/B pixels)</li>
                <li><strong>Step 2:</strong> Measure distance from dot to each edge</li>
                <li><strong>Step 3:</strong> Compare with original dimensions to calculate crop amounts</li>
                <li><strong>Step 4:</strong> Convert pixel differences back to 3-bit values</li>
                <li><strong>Step 5:</strong> Reconstruct 12-bit tracking ID from edge values</li>
                <li><strong>Note:</strong> Original dimensions are required for accurate decoding</li>
            </ul>
        </div>
    </div>

    <script>
        const imageFileInput = document.getElementById('imageFile');
        const origWidthInput = document.getElementById('origWidth');
        const origHeightInput = document.getElementById('origHeight');
        const decodeBtn = document.getElementById('decodeBtn');
        const statusDiv = document.getElementById('status');
        const previewContainer = document.getElementById('previewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const detectionCanvas = document.getElementById('detectionCanvas');
        const resultBox = document.getElementById('resultBox');
        const trackingIdDisplay = document.getElementById('trackingIdDisplay');
        const binaryDisplay = document.getElementById('binaryDisplay');
        const detailsBody = document.getElementById('detailsBody');

        let imageFile = null;

        imageFileInput.addEventListener('change', (e) => {
            imageFile = e.target.files[0];
            if (imageFile) {
                const url = URL.createObjectURL(imageFile);
                imagePreview.src = url;
                previewContainer.style.display = 'flex';
                resultBox.style.display = 'none';
                showStatus(`Image loaded: ${imageFile.name}`, 'info');
            }
        });

        decodeBtn.addEventListener('click', async () => {
            if (!imageFile) {
                showStatus('Please select an image file first!', 'error');
                return;
            }

            const origWidth = parseInt(origWidthInput.value);
            const origHeight = parseInt(origHeightInput.value);

            if (!origWidth || !origHeight || origWidth < 1 || origHeight < 1) {
                showStatus('Please enter the original image dimensions!', 'error');
                return;
            }

            decodeBtn.disabled = true;
            showStatus('Decoding watermark...', 'info');

            try {
                await decodeImage(imageFile, origWidth, origHeight);
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                decodeBtn.disabled = false;
            }
        });

        // Find the red center dot in the image
        function findRedCenterDot(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Search in the center region (middle 60% of image)
            const searchMargin = 0.2;
            const startX = Math.floor(width * searchMargin);
            const endX = Math.floor(width * (1 - searchMargin));
            const startY = Math.floor(height * searchMargin);
            const endY = Math.floor(height * (1 - searchMargin));

            let bestMatch = { x: 0, y: 0, score: 0, samples: [] };

            // First pass: find red pixels
            const redPixels = [];
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];

                    // Look for red pixels (high R, low G, low B)
                    const redScore = r - Math.max(g, b);
                    if (redScore > 80 && r > 120) {
                        redPixels.push({ x, y, r, g, b, score: redScore });
                    }
                }
            }

            if (redPixels.length === 0) {
                return { x: width / 2, y: height / 2, found: false, confidence: 0 };
            }

            // Find the cluster of red pixels (center of mass)
            let sumX = 0, sumY = 0, totalWeight = 0;
            for (const pixel of redPixels) {
                const weight = pixel.score;
                sumX += pixel.x * weight;
                sumY += pixel.y * weight;
                totalWeight += weight;
            }

            const centerX = Math.round(sumX / totalWeight);
            const centerY = Math.round(sumY / totalWeight);

            // Verify by checking the area around the detected center
            let verifyScore = 0;
            const verifyRadius = 5;
            for (let dy = -verifyRadius; dy <= verifyRadius; dy++) {
                for (let dx = -verifyRadius; dx <= verifyRadius; dx++) {
                    const nx = centerX + dx;
                    const ny = centerY + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const idx = (ny * width + nx) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        if (r > 120 && r - Math.max(g, b) > 60) {
                            verifyScore++;
                        }
                    }
                }
            }

            const confidence = Math.min(100, Math.round((verifyScore / ((verifyRadius * 2 + 1) ** 2)) * 100));

            return {
                x: centerX,
                y: centerY,
                found: verifyScore > 10,
                confidence,
                redPixelCount: redPixels.length
            };
        }

        // Draw detection visualization
        function drawDetectionVisualization(ctx, img, centerDot, currentWidth, currentHeight) {
            // Draw the image
            ctx.drawImage(img, 0, 0, currentWidth, currentHeight);

            if (centerDot.found) {
                // Draw crosshair at detected center
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;

                // Vertical line
                ctx.beginPath();
                ctx.moveTo(centerDot.x, 0);
                ctx.lineTo(centerDot.x, currentHeight);
                ctx.stroke();

                // Horizontal line
                ctx.beginPath();
                ctx.moveTo(0, centerDot.y);
                ctx.lineTo(currentWidth, centerDot.y);
                ctx.stroke();

                // Circle around detected dot
                ctx.beginPath();
                ctx.arc(centerDot.x, centerDot.y, 15, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Label
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`Center: (${centerDot.x}, ${centerDot.y})`, centerDot.x + 20, centerDot.y - 20);
            }

            // Draw edge measurements
            ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.font = '12px Arial';

            // Show distances
            if (centerDot.found) {
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;

                const labels = [
                    { text: `Top: ${centerDot.y}px`, x: currentWidth / 2, y: 20 },
                    { text: `Bottom: ${currentHeight - centerDot.y}px`, x: currentWidth / 2, y: currentHeight - 10 },
                    { text: `Left: ${centerDot.x}px`, x: 10, y: currentHeight / 2 },
                    { text: `Right: ${currentWidth - centerDot.x}px`, x: currentWidth - 80, y: currentHeight / 2 }
                ];

                for (const label of labels) {
                    ctx.strokeText(label.text, label.x, label.y);
                    ctx.fillText(label.text, label.x, label.y);
                }
            }
        }

        async function decodeImage(file, origWidth, origHeight) {
            // Load the image
            const img = new Image();
            img.src = URL.createObjectURL(file);
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });

            const currentWidth = img.width;
            const currentHeight = img.height;

            showStatus(`Image: ${currentWidth}x${currentHeight} (Original: ${origWidth}x${origHeight})`, 'info');

            // Create canvas for analysis
            const canvas = document.createElement('canvas');
            canvas.width = currentWidth;
            canvas.height = currentHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, currentWidth, currentHeight);

            // Find the red center dot
            showStatus('Searching for center dot...', 'info');
            const centerDot = findRedCenterDot(imageData);

            // Setup detection canvas for visualization
            detectionCanvas.width = currentWidth;
            detectionCanvas.height = currentHeight;
            const detCtx = detectionCanvas.getContext('2d');
            drawDetectionVisualization(detCtx, img, centerDot, currentWidth, currentHeight);

            // Calculate the tracking ID
            let trackingId = 0;
            let confidence = 'low';
            const baseUnit = 2;

            detailsBody.innerHTML = '';

            if (centerDot.found) {
                // Calculate distances from center dot to edges
                const distTop = centerDot.y;
                const distBottom = currentHeight - centerDot.y;
                const distLeft = centerDot.x;
                const distRight = currentWidth - centerDot.x;

                // Original center position
                const origCenterX = origWidth / 2;
                const origCenterY = origHeight / 2;

                // Calculate how much was cropped from each side
                const topCrop = Math.max(0, Math.round(origCenterY - distTop));
                const bottomCrop = Math.max(0, Math.round(origCenterY - distBottom));
                const leftCrop = Math.max(0, Math.round(origCenterX - distLeft));
                const rightCrop = Math.max(0, Math.round(origCenterX - distRight));

                // Convert to 3-bit values
                const topBits = Math.min(7, Math.round(topCrop / baseUnit)) & 0x7;
                const rightBits = Math.min(7, Math.round(rightCrop / baseUnit)) & 0x7;
                const bottomBits = Math.min(7, Math.round(bottomCrop / baseUnit)) & 0x7;
                const leftBits = Math.min(7, Math.round(leftCrop / baseUnit)) & 0x7;

                // Reconstruct tracking ID
                trackingId = (topBits << 9) | (rightBits << 6) | (bottomBits << 3) | leftBits;

                confidence = centerDot.confidence > 70 ? 'high' : centerDot.confidence > 40 ? 'medium' : 'low';

                // Add details rows
                addDetailRow('Center Dot Found', `(${centerDot.x}, ${centerDot.y})`, `confidence-${confidence}`, `${centerDot.confidence}%`);
                addDetailRow('Red Pixels Detected', centerDot.redPixelCount, '', '');
                addDetailRow('', '', '', '');
                addDetailRow('Distance to Top', `${distTop}px`, '', `Crop: ${topCrop}px → bits: ${topBits}`);
                addDetailRow('Distance to Right', `${distRight}px`, '', `Crop: ${rightCrop}px → bits: ${rightBits}`);
                addDetailRow('Distance to Bottom', `${distBottom}px`, '', `Crop: ${bottomCrop}px → bits: ${bottomBits}`);
                addDetailRow('Distance to Left', `${distLeft}px`, '', `Crop: ${leftCrop}px → bits: ${leftBits}`);
                addDetailRow('', '', '', '');
                addDetailRow('Current Dimensions', `${currentWidth} x ${currentHeight}`, '', '');
                addDetailRow('Original Dimensions', `${origWidth} x ${origHeight}`, '', '');
                addDetailRow('Total Removed', `W: ${origWidth - currentWidth}px, H: ${origHeight - currentHeight}px`, '', '');

            } else {
                addDetailRow('Center Dot', 'NOT FOUND', 'confidence-low', 'Cannot decode');
                addDetailRow('Current Dimensions', `${currentWidth} x ${currentHeight}`, '', '');

                showStatus('Center dot not found. Image may not be watermarked or dot was removed.', 'error');
            }

            // Display result
            trackingIdDisplay.textContent = centerDot.found ? trackingId : 'N/A';

            if (centerDot.found) {
                const binaryStr = trackingId.toString(2).padStart(12, '0');
                binaryDisplay.innerHTML = `
                    <strong>Binary:</strong> ${binaryStr}<br>
                    <strong>Bit Groups:</strong> [${binaryStr.slice(0,3)}] [${binaryStr.slice(3,6)}] [${binaryStr.slice(6,9)}] [${binaryStr.slice(9,12)}]<br>
                    <strong>Confidence:</strong> ${centerDot.confidence}%
                `;
                showStatus(`Tracking ID detected: ${trackingId} (Confidence: ${centerDot.confidence}%)`, 'success');
            } else {
                binaryDisplay.textContent = 'Unable to decode - center dot not found';
            }

            resultBox.style.display = 'block';
            resultBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function addDetailRow(label, value, confidenceClass = '', extra = '') {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td><strong>${label}</strong></td>
                <td class="${confidenceClass}">${value}</td>
                <td>${extra}</td>
            `;
            detailsBody.appendChild(row);
        }

        function showStatus(message, type = 'info') {
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }
    </script>
</body>
</html>
