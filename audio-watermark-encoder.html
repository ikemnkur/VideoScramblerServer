<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Watermark Encoder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            max-width: 900px;
            width: 100%;
            padding: 40px;
        }

        h1 {
            color: #1a1a2e;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="file"],
        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input:hover {
            border-color: #1a1a2e;
        }

        input:focus {
            outline: none;
            border-color: #1a1a2e;
        }

        .options-row {
            display: flex;
            gap: 20px;
            margin-bottom: 25px;
        }

        .options-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }

        button {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(26, 26, 46, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
            border-left: 4px solid #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #c62828;
        }

        .preview {
            margin-top: 20px;
        }

        audio {
            width: 100%;
            margin-top: 10px;
        }

        .info-box {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            font-size: 13px;
            color: #555;
        }

        .info-box h3 {
            color: #1a1a2e;
            margin-bottom: 8px;
            font-size: 15px;
        }

        .info-box ul {
            margin-left: 20px;
            margin-top: 8px;
        }

        .info-box li {
            margin-bottom: 4px;
        }

        .encoding-details {
            background: #e8f5e9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 13px;
        }

        .encoding-details strong {
            color: #2e7d32;
        }

        .waveform-container {
            margin-top: 20px;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 10px;
        }

        canvas {
            width: 100%;
            height: 100px;
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #11998e, #38ef7d);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Watermark Encoder</h1>
        <p class="subtitle">Embed a tracking ID (0-65535) using multi-tone spread spectrum watermarking</p>

        <div class="input-group">
            <label for="audioFile">Select Audio File:</label>
            <input type="file" id="audioFile" accept="audio/*">
        </div>

        <div class="options-row">
            <div class="input-group">
                <label for="trackingId">Tracking ID (0-65535, 16-bit):</label>
                <input type="number" id="trackingId" min="0" max="65535" placeholder="Enter tracking ID...">
            </div>
            <div class="input-group">
                <label for="watermarkGain">Watermark Volume (0.01-0.1):</label>
                <input type="number" id="watermarkGain" min="0.01" max="0.1" step="0.01" value="0.03">
            </div>
        </div>

        <button id="encodeBtn">Encode Watermark</button>

        <div id="status"></div>

        <div class="progress-bar" id="progressBar" style="display: none;">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>

        <div class="preview" id="previewSection" style="display: none;">
            <h3>Original Audio:</h3>
            <audio id="originalAudio" controls></audio>
            <h3 style="margin-top: 15px;">Watermarked Audio:</h3>
            <audio id="watermarkedAudio" controls></audio>
        </div>

        <div class="waveform-container" id="waveformContainer" style="display: none;">
            <canvas id="waveformCanvas"></canvas>
        </div>

        <div class="encoding-details" id="encodingDetails" style="display: none;"></div>

        <div class="info-box">
            <h3>Multi-Tone Spread Spectrum Watermarking:</h3>
            <ul>
                <li><strong>Sync Marker:</strong> A unique frequency sweep (150-250 Hz over 0.2s) marks the start of each data block</li>
                <li><strong>Data Encoding:</strong> Each bit encoded using dual-tone FSK (Frequency Shift Keying)</li>
                <li><strong>Bit 0:</strong> 180 Hz tone for 50ms</li>
                <li><strong>Bit 1:</strong> 220 Hz tone for 50ms</li>
                <li><strong>16-bit capacity:</strong> Stores tracking IDs 0-65535</li>
                <li><strong>Redundancy:</strong> Pattern repeats every 10 seconds for robustness</li>
                <li><strong>Frequency Range:</strong> 150-250 Hz (survives MP3 compression, hard to hear)</li>
            </ul>
        </div>
    </div>

    <script>
        const audioFileInput = document.getElementById('audioFile');
        const trackingIdInput = document.getElementById('trackingId');
        const watermarkGainInput = document.getElementById('watermarkGain');
        const encodeBtn = document.getElementById('encodeBtn');
        const statusDiv = document.getElementById('status');
        const originalAudio = document.getElementById('originalAudio');
        const watermarkedAudio = document.getElementById('watermarkedAudio');
        const previewSection = document.getElementById('previewSection');
        const waveformContainer = document.getElementById('waveformContainer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const encodingDetails = document.getElementById('encodingDetails');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');

        let audioFile = null;

        // Watermark configuration
        const CONFIG = {
            // Frequencies for encoding
            SYNC_FREQ_START: 150,      // Sync chirp start frequency
            SYNC_FREQ_END: 250,        // Sync chirp end frequency
            SYNC_DURATION: 0.2,        // Sync chirp duration in seconds

            BIT_0_FREQ: 180,           // Frequency for bit 0
            BIT_1_FREQ: 220,           // Frequency for bit 1
            BIT_DURATION: 0.05,        // Duration per bit (50ms)

            GAP_DURATION: 0.02,        // Gap between bits (20ms)

            REPEAT_INTERVAL: 10,       // Repeat watermark every 10 seconds

            // Total watermark duration: sync(0.2) + 16 bits * (0.05 + 0.02) = 0.2 + 1.12 = ~1.32 seconds
        };

        audioFileInput.addEventListener('change', (e) => {
            audioFile = e.target.files[0];
            if (audioFile) {
                const url = URL.createObjectURL(audioFile);
                originalAudio.src = url;
                previewSection.style.display = 'block';
                watermarkedAudio.style.display = 'none';
                encodingDetails.style.display = 'none';
                waveformContainer.style.display = 'none';
                showStatus(`Audio loaded: ${audioFile.name}`, 'info');
            }
        });

        encodeBtn.addEventListener('click', async () => {
            if (!audioFile) {
                showStatus('Please select an audio file first!', 'error');
                return;
            }

            const trackingId = parseInt(trackingIdInput.value);
            if (isNaN(trackingId) || trackingId < 0 || trackingId > 65535) {
                showStatus('Please enter a valid tracking ID (0-65535)!', 'error');
                return;
            }

            const gain = parseFloat(watermarkGainInput.value);
            if (isNaN(gain) || gain < 0.01 || gain > 0.1) {
                showStatus('Please enter a valid watermark volume (0.01-0.1)!', 'error');
                return;
            }

            encodeBtn.disabled = true;
            progressBar.style.display = 'block';
            showStatus('Loading audio file...', 'info');

            try {
                await encodeAudio(audioFile, trackingId, gain);
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                encodeBtn.disabled = false;
            }
        });

        // Convert tracking ID to 16-bit binary array
        function toBinaryArray(num) {
            const arr = [];
            for (let i = 15; i >= 0; i--) {
                arr.push((num >> i) & 1);
            }
            return arr;
        }

        // Generate a frequency sweep (chirp) for sync marker
        function generateSyncChirp(sampleRate, duration, startFreq, endFreq) {
            const numSamples = Math.floor(sampleRate * duration);
            const samples = new Float32Array(numSamples);

            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                // Linear frequency sweep
                const freq = startFreq + (endFreq - startFreq) * (t / duration);
                // Smooth envelope to reduce clicks
                const envelope = Math.sin(Math.PI * t / duration);
                samples[i] = Math.sin(2 * Math.PI * freq * t) * envelope;
            }

            return samples;
        }

        // Generate a tone for a single bit
        function generateBitTone(sampleRate, duration, frequency) {
            const numSamples = Math.floor(sampleRate * duration);
            const samples = new Float32Array(numSamples);

            for (let i = 0; i < numSamples; i++) {
                const t = i / sampleRate;
                // Smooth envelope to reduce clicks
                const attackRelease = 0.005; // 5ms attack/release
                let envelope = 1.0;
                if (t < attackRelease) {
                    envelope = t / attackRelease;
                } else if (t > duration - attackRelease) {
                    envelope = (duration - t) / attackRelease;
                }
                samples[i] = Math.sin(2 * Math.PI * frequency * t) * envelope;
            }

            return samples;
        }

        // Generate silence
        function generateSilence(sampleRate, duration) {
            const numSamples = Math.floor(sampleRate * duration);
            return new Float32Array(numSamples);
        }

        // Generate complete watermark signal for one instance
        function generateWatermarkSignal(sampleRate, trackingId) {
            const binaryData = toBinaryArray(trackingId);
            const segments = [];

            // Add sync chirp
            segments.push(generateSyncChirp(
                sampleRate,
                CONFIG.SYNC_DURATION,
                CONFIG.SYNC_FREQ_START,
                CONFIG.SYNC_FREQ_END
            ));

            // Add small gap after sync
            segments.push(generateSilence(sampleRate, CONFIG.GAP_DURATION));

            // Add each bit
            for (let i = 0; i < 16; i++) {
                const freq = binaryData[i] ? CONFIG.BIT_1_FREQ : CONFIG.BIT_0_FREQ;
                segments.push(generateBitTone(sampleRate, CONFIG.BIT_DURATION, freq));

                // Add gap between bits (except after last bit)
                if (i < 15) {
                    segments.push(generateSilence(sampleRate, CONFIG.GAP_DURATION));
                }
            }

            // Concatenate all segments
            const totalLength = segments.reduce((sum, seg) => sum + seg.length, 0);
            const watermark = new Float32Array(totalLength);
            let offset = 0;
            for (const segment of segments) {
                watermark.set(segment, offset);
                offset += segment.length;
            }

            return watermark;
        }

        async function encodeAudio(file, trackingId, gain) {
            // Create audio context
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const sampleRate = audioContext.sampleRate;

            // Load and decode audio file
            const arrayBuffer = await file.arrayBuffer();
            updateProgress(10);
            showStatus('Decoding audio...', 'info');

            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            updateProgress(30);

            const numChannels = audioBuffer.numberOfChannels;
            const length = audioBuffer.length;
            const duration = audioBuffer.duration;

            showStatus(`Audio: ${duration.toFixed(2)}s, ${sampleRate}Hz, ${numChannels} channel(s)`, 'info');

            // Generate watermark signal
            const watermarkSignal = generateWatermarkSignal(sampleRate, trackingId);
            const watermarkDuration = watermarkSignal.length / sampleRate;

            // Calculate how many times to embed the watermark
            const repeatCount = Math.floor(duration / CONFIG.REPEAT_INTERVAL);
            const embedCount = Math.max(1, repeatCount);

            showStatus(`Embedding watermark ${embedCount} time(s)...`, 'info');

            // Create output buffer
            const outputBuffer = audioContext.createBuffer(numChannels, length, sampleRate);

            // Copy original audio and add watermark
            for (let channel = 0; channel < numChannels; channel++) {
                const inputData = audioBuffer.getChannelData(channel);
                const outputData = outputBuffer.getChannelData(channel);

                // Copy original audio
                outputData.set(inputData);

                // Embed watermark at regular intervals
                for (let i = 0; i < embedCount; i++) {
                    const startSample = Math.floor(i * CONFIG.REPEAT_INTERVAL * sampleRate);

                    // Add 1 second offset to avoid the very beginning
                    const offsetStart = startSample + Math.floor(sampleRate * 1);

                    // Make sure we don't exceed buffer length
                    const endSample = Math.min(offsetStart + watermarkSignal.length, length);

                    for (let j = offsetStart; j < endSample; j++) {
                        const wmIndex = j - offsetStart;
                        if (wmIndex < watermarkSignal.length) {
                            outputData[j] += watermarkSignal[wmIndex] * gain;
                            // Clip to prevent distortion
                            outputData[j] = Math.max(-1, Math.min(1, outputData[j]));
                        }
                    }
                }

                updateProgress(30 + (channel + 1) / numChannels * 30);
            }

            showStatus('Encoding output file...', 'info');

            // Convert to WAV
            const wavBlob = await audioBufferToWav(outputBuffer);
            updateProgress(90);

            // Create download URL
            const url = URL.createObjectURL(wavBlob);
            watermarkedAudio.src = url;
            watermarkedAudio.style.display = 'block';

            // Trigger download
            const a = document.createElement('a');
            a.href = url;
            const baseName = file.name.replace(/\.[^/.]+$/, '');
            a.download = `watermarked_${baseName}_id${trackingId}.wav`;
            a.click();

            // Draw waveform
            drawWaveform(outputBuffer.getChannelData(0), watermarkSignal, sampleRate);
            waveformContainer.style.display = 'block';

            // Show encoding details
            const binaryStr = toBinaryArray(trackingId).join('');
            encodingDetails.innerHTML = `
                <strong>Encoding Complete!</strong><br><br>
                <strong>Tracking ID:</strong> ${trackingId}<br>
                <strong>Binary:</strong> ${binaryStr}<br><br>
                <strong>Watermark Settings:</strong><br>
                &nbsp;&nbsp;Sync Chirp: ${CONFIG.SYNC_FREQ_START}-${CONFIG.SYNC_FREQ_END} Hz (${CONFIG.SYNC_DURATION}s)<br>
                &nbsp;&nbsp;Bit 0 Frequency: ${CONFIG.BIT_0_FREQ} Hz<br>
                &nbsp;&nbsp;Bit 1 Frequency: ${CONFIG.BIT_1_FREQ} Hz<br>
                &nbsp;&nbsp;Bit Duration: ${CONFIG.BIT_DURATION * 1000}ms<br>
                &nbsp;&nbsp;Watermark Duration: ${watermarkDuration.toFixed(3)}s<br>
                &nbsp;&nbsp;Embedded: ${embedCount} time(s) every ${CONFIG.REPEAT_INTERVAL}s<br>
                &nbsp;&nbsp;Gain: ${gain}
            `;
            encodingDetails.style.display = 'block';

            updateProgress(100);
            showStatus('Audio watermarked successfully! Download started.', 'success');

            // Clean up
            audioContext.close();
        }

        // Convert AudioBuffer to WAV blob
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;

            const dataLength = buffer.length * blockAlign;
            const bufferLength = 44 + dataLength;

            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, bufferLength - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // fmt chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            // Interleave channels and write samples
            const channels = [];
            for (let i = 0; i < numChannels; i++) {
                channels.push(buffer.getChannelData(i));
            }

            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let ch = 0; ch < numChannels; ch++) {
                    const sample = Math.max(-1, Math.min(1, channels[ch][i]));
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
            }

            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function drawWaveform(audioData, watermarkData, sampleRate) {
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = 200;

            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw watermark signal (first 2 seconds)
            const samplesToShow = Math.min(sampleRate * 2, watermarkData.length);
            const step = Math.ceil(samplesToShow / width);

            ctx.strokeStyle = '#38ef7d';
            ctx.lineWidth = 1;
            ctx.beginPath();

            for (let i = 0; i < width; i++) {
                const sampleIndex = Math.floor(i * samplesToShow / width);
                const value = watermarkData[sampleIndex] || 0;
                const y = (1 - value) * height / 2;

                if (i === 0) {
                    ctx.moveTo(i, y);
                } else {
                    ctx.lineTo(i, y);
                }
            }

            ctx.stroke();

            // Draw labels
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText('Watermark Signal (first 2 seconds)', 10, 20);
            ctx.fillText('Sync Chirp', 10, height - 10);
            ctx.fillText('Data Bits', 150, height - 10);
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showStatus(message, type = 'info') {
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
        }
    </script>
</body>
</html>
